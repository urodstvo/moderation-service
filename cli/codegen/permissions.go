package codegen

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

type PermissionDef struct {
	Key         string `yaml:"key"`
	Description string `yaml:"description,omitempty"`
}

type RoleDef struct {
	Permissions []string `yaml:"permissions"`
}

type PermissionsConfig struct {
	Permissions []PermissionDef    `yaml:"permissions"`
	Roles       map[string]RoleDef `yaml:"roles"`
}

var constNameRegexp = regexp.MustCompile(`[^a-zA-Z0-9]+`)
var titleCaser = cases.Title(language.English)

func toConstName(key string) string {
	parts := constNameRegexp.Split(key, -1)
	var nameParts []string
	for _, part := range parts {
		if part == "" {
			continue
		}
		nameParts = append(nameParts, titleCaser.String(part))
	}
	return "Perm" + strings.Join(nameParts, "")
}

func NewPermissionsCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "permission [output_go_file]",
		Short: "Generate Go code for permissions and roles from YAML",
		Args:  cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			input := `./configs/permissions.yaml`
			output := args[0]

			pkgNameFlag, err := cmd.Flags().GetString("package")
			if err != nil {
				return fmt.Errorf("failed to get 'package' flag: %w", err)
			}
			var pkgName string
			if cmd.Flags().Changed("package") {
				pkgName = pkgNameFlag
			} else {
				dir := filepath.Dir(output)
				base := filepath.Base(dir)
				if base == "" || base == "." {
					pkgName = "permissions"
				} else {
					pkgName = base
				}
			}

			cfg, err := loadPermissionsConfig(input)
			if err != nil {
				return err
			}
			code, err := generatePermissionsCode(cfg, pkgName, input)
			if err != nil {
				return fmt.Errorf("failed to generate code: %w", err)
			}
			if err := os.MkdirAll(filepath.Dir(output), 0755); err != nil {
				return fmt.Errorf("failed to create dir for %q: %w", output, err)
			}
			if err := os.WriteFile(output, code, 0644); err != nil {
				return fmt.Errorf("failed to write file %q: %w", output, err)
			}
			fmt.Printf("Generated %s (package %q)\n", output, pkgName)
			return nil
		},
	}
	cmd.Flags().StringP("package", "p", "permissions", "Package name for generated file")
	return cmd
}

func loadPermissionsConfig(path string) (*PermissionsConfig, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading YAML file: %v\n", err)
		os.Exit(1)
	}
	var cfg PermissionsConfig
	if err := yaml.Unmarshal(data, &cfg); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing YAML: %v\n", err)
		os.Exit(1)
	}

	permKeys := make(map[string]struct{}, len(cfg.Permissions))
	for _, p := range cfg.Permissions {
		if p.Key == "" {
			return nil, fmt.Errorf("Empty permission key found\n")
		}
		if _, exists := permKeys[p.Key]; exists {
			return nil, fmt.Errorf("Duplicate permission key: %q\n", p.Key)
		}
		permKeys[p.Key] = struct{}{}
	}
	for roleName, roleDef := range cfg.Roles {
		if len(roleDef.Permissions) == 0 {
			// fmt.Fprintf(os.Stderr, "Warning: role %q has no permissions\n", roleName)
		}
		for _, pk := range roleDef.Permissions {
			if _, ok := permKeys[pk]; !ok {
				return nil, fmt.Errorf("Role %q references unknown permission %q\n", roleName, pk)
			}
		}
	}

	sort.Slice(cfg.Permissions, func(i, j int) bool {
		return cfg.Permissions[i].Key < cfg.Permissions[j].Key
	})

	return &cfg, nil
}

func generatePermissionsCode(cfg *PermissionsConfig, pkgName, input string) ([]byte, error) {
	var buf bytes.Buffer
	buf.WriteString("// Code generated by codegen/permissions.go; DO NOT EDIT.\n")
	buf.WriteString("// Source YAML: " + input + "\n\n")
	buf.WriteString("package " + pkgName + "\n\n")

	buf.WriteString("const (\n")
	for _, p := range cfg.Permissions {
		constName := toConstName(p.Key)
		if p.Description != "" {
			buf.WriteString(fmt.Sprintf("    // %s\n", p.Description))
		}
		buf.WriteString(fmt.Sprintf("    %s = %q\n", constName, p.Key))
	}
	buf.WriteString(")\n\n")

	roleNames := make([]string, 0, len(cfg.Roles))
	for role := range cfg.Roles {
		roleNames = append(roleNames, role)
	}
	sort.Strings(roleNames)

	buf.WriteString("// RolePermissions includes the list of permissions for each role\n")
	buf.WriteString("var RolePermissions = map[string][]string{\n")
	for _, role := range roleNames {
		roleDef := cfg.Roles[role]
		perms := make([]string, len(roleDef.Permissions))
		copy(perms, roleDef.Permissions)
		sort.Strings(perms)
		buf.WriteString(fmt.Sprintf("    %q: []string{\n", role))
		for _, pk := range perms {
			constName := toConstName(pk)
			buf.WriteString(fmt.Sprintf("        %s,\n", constName))
		}
		buf.WriteString("    },\n")
	}
	buf.WriteString("}\n\n")

	buf.WriteString("// AllPermissions â€” a list of all permissions (keys)\n")
	buf.WriteString("var AllPermissions = []string{\n")
	for _, p := range cfg.Permissions {
		constName := toConstName(p.Key)
		buf.WriteString(fmt.Sprintf("    %s,\n", constName))
	}
	buf.WriteString("}\n")

	return buf.Bytes(), nil
}
